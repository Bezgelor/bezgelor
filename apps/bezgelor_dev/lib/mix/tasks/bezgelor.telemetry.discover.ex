defmodule Mix.Tasks.Bezgelor.Telemetry.Discover do
  @moduledoc """
  Discovers telemetry events declared across all umbrella apps.

  Scans for modules with `@telemetry_events` attribute and generates
  a consolidated metrics configuration.

  ## Usage

      mix bezgelor.telemetry.discover

  ## Options

      --output PATH   Output file path (default: prints to stdout)
      --format FORMAT Output format: elixir, json (default: elixir)
  """

  use Mix.Task

  alias BezgelorCore.TelemetryEvent

  @shortdoc "Discover telemetry events across all apps"

  @impl Mix.Task
  def run(args) do
    {opts, _, _} = OptionParser.parse(args, switches: [output: :string, format: :string])
    format = Keyword.get(opts, :format, "elixir")
    output = Keyword.get(opts, :output)

    # Ensure all apps are compiled and loaded (but not started)
    Mix.Task.run("compile", ["--no-warnings-as-errors"])
    Mix.Task.run("loadpaths")

    # Get all modules from umbrella apps
    apps = [
      :bezgelor_core,
      :bezgelor_db,
      :bezgelor_protocol,
      :bezgelor_world,
      :bezgelor_auth,
      :bezgelor_realm,
      :bezgelor_portal
    ]

    # Load all apps to make modules available (without starting)
    Enum.each(apps, &Application.load/1)

    # Known modules with telemetry events
    known_telemetry_modules = [
      BezgelorAuth.Sts.Handler.AuthHandler,
      BezgelorProtocol.Handler.RealmAuthHandler,
      BezgelorProtocol.Handler.WorldEntryHandler,
      BezgelorWorld.CreatureManager,
      BezgelorWorld.CreatureDeath,
      BezgelorWorld.Handler.QuestHandler,
      BezgelorCore.TelemetryEvent
    ]

    # Ensure all modules are loaded
    Enum.each(known_telemetry_modules, &Code.ensure_loaded/1)

    # First try known modules, then fall back to app module scan
    events_from_known =
      known_telemetry_modules
      |> Enum.flat_map(&extract_events_from_module/1)
      |> Enum.map(&add_source_info/1)

    events_from_apps =
      apps
      |> Enum.flat_map(&get_app_modules/1)
      |> Enum.flat_map(&extract_events_from_module/1)
      |> Enum.map(&add_source_info/1)

    # Combine and deduplicate
    events = Enum.uniq_by(events_from_known ++ events_from_apps, & &1.event)

    # Validate all events
    invalid = Enum.reject(events, fn e -> TelemetryEvent.validate(e) == :ok end)

    if invalid != [] do
      Mix.shell().error("Invalid telemetry events found:")

      Enum.each(invalid, fn e ->
        {:error, msg} = TelemetryEvent.validate(e)
        Mix.shell().error("  - #{inspect(e.event)}: #{msg}")
      end)

      exit({:shutdown, 1})
    end

    # Group by domain
    by_domain = Enum.group_by(events, & &1.domain)

    # Output
    output_content = format_output(by_domain, format)

    if output do
      File.write!(output, output_content)
      Mix.shell().info("Wrote #{length(events)} events to #{output}")
    else
      Mix.shell().info(output_content)
    end

    # Summary
    Mix.shell().info("\nSummary:")

    Enum.each(by_domain, fn {domain, domain_events} ->
      Mix.shell().info("  #{domain}: #{length(domain_events)} events")
    end)

    Mix.shell().info("  Total: #{length(events)} events")
  end

  @doc "Extract @telemetry_events from a module."
  def extract_events_from_module(module) do
    if function_exported?(module, :telemetry_events, 0) do
      module.telemetry_events()
    else
      try do
        module.__info__(:attributes)
        |> Keyword.get_values(:telemetry_events)
        |> List.flatten()
      rescue
        _ -> []
      end
    end
  end

  defp get_app_modules(app) do
    case :application.get_key(app, :modules) do
      {:ok, modules} -> modules
      :undefined -> []
    end
  end

  defp add_source_info(event) do
    Map.put_new(event, :source_module, "unknown")
  end

  defp format_output(by_domain, "elixir") do
    """
    # Auto-generated by mix bezgelor.telemetry.discover
    # Do not edit manually - regenerate with: mix bezgelor.telemetry.discover --output <path>

    defmodule BezgelorPortal.Telemetry.DiscoveredMetrics do
      @moduledoc \"\"\"
      Auto-discovered telemetry metrics from all umbrella apps.
      \"\"\"

      import Telemetry.Metrics

      def metrics do
        [
    #{format_metrics(by_domain)}
        ]
      end
    end
    """
  end

  defp format_output(by_domain, "json") do
    Jason.encode!(by_domain, pretty: true)
  end

  defp format_output(by_domain, _), do: format_output(by_domain, "elixir")

  defp format_metrics(by_domain) do
    by_domain
    |> Enum.flat_map(fn {domain, events} ->
      [
        "      # #{String.capitalize(to_string(domain))} Metrics"
        | Enum.flat_map(events, &format_event_metrics/1)
      ]
    end)
    |> Enum.join(",\n")
  end

  defp format_event_metrics(event) do
    event_name = Enum.join(event.event, ".")

    Enum.map(event.measurements, fn measurement ->
      tags = inspect(event.tags)

      """
            summary("#{event_name}.#{measurement}",
              tags: #{tags},
              description: "#{event.description}"
            )
      """
      |> String.trim()
    end)
  end
end
